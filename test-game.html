<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Cribbage Game Simulator</title>
    <style>
        body {
            font-family: 'Courier New', monospace;
            max-width: 1200px;
            margin: 20px auto;
            padding: 20px;
            background-color: #1e1e1e;
            color: #d4d4d4;
        }
        h1 {
            color: #4ec9b0;
        }
        .controls {
            margin: 20px 0;
            padding: 15px;
            background-color: #2d2d2d;
            border-radius: 5px;
        }
        button {
            padding: 10px 20px;
            margin: 5px;
            background-color: #0e639c;
            color: white;
            border: none;
            border-radius: 3px;
            cursor: pointer;
            font-size: 14px;
        }
        button:hover {
            background-color: #1177bb;
        }
        button:disabled {
            background-color: #3e3e3e;
            cursor: not-allowed;
        }
        .stats {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin: 20px 0;
        }
        .stat-box {
            background-color: #2d2d2d;
            padding: 15px;
            border-radius: 5px;
            border-left: 4px solid #4ec9b0;
        }
        .stat-label {
            color: #808080;
            font-size: 12px;
            text-transform: uppercase;
        }
        .stat-value {
            font-size: 24px;
            font-weight: bold;
            color: #4ec9b0;
            margin-top: 5px;
        }
        #log {
            background-color: #2d2d2d;
            padding: 15px;
            border-radius: 5px;
            height: 500px;
            overflow-y: auto;
            font-size: 13px;
            line-height: 1.5;
        }
        .error {
            color: #f48771;
            font-weight: bold;
        }
        .warning {
            color: #dcdcaa;
        }
        .success {
            color: #4ec9b0;
        }
        .game-separator {
            border-top: 2px solid #4ec9b0;
            margin: 15px 0;
            padding-top: 10px;
        }
        .input-group {
            margin: 10px 0;
        }
        .input-group label {
            display: inline-block;
            width: 150px;
            color: #9cdcfe;
        }
        .input-group input {
            padding: 5px 10px;
            background-color: #3c3c3c;
            border: 1px solid #555;
            color: #d4d4d4;
            border-radius: 3px;
            width: 100px;
        }
    </style>
</head>
<body>
    <h1>üÉè Cribbage Game Simulator & Tester</h1>
    
    <div class="controls">
        <h3 style="margin-top: 0; color: #9cdcfe;">Test Coverage</h3>
        <p style="font-size: 12px; color: #808080; margin: 10px 0;">
            This comprehensive test suite validates:<br>
            ‚úì Both players can't reach 121+ (game ends at first 121)<br>
            ‚úì Scores never decrease<br>
            ‚úì Count stays 0-31, resets properly after "go"<br>
            ‚úì Card counts correct (6 dealt, 4 after discard, 4 in crib)<br>
            ‚úì Turn management (correct player's turn)<br>
            ‚úì Dealer assignment and rotation<br>
            ‚úì State transitions (CUT ‚Üí DISCARD ‚Üí PLAY ‚Üí scoring)<br>
            ‚úì No duplicate cards in play<br>
            ‚úì Played pile count matches current count<br>
            ‚úì Cut card exists during play<br>
            ‚úì Game reaches GAME_OVER with winner at 121+
        </p>
        <div class="input-group">
            <label for="numGames">Number of games:</label>
            <input type="number" id="numGames" value="10" min="1" max="1000">
        </div>
        <div class="input-group">
            <label for="delay">Delay (ms):</label>
            <input type="number" id="delay" value="0" min="0" max="1000">
        </div>
        <button id="runSimulation">Run Simulation</button>
        <button id="runSingleGame">Run Single Game</button>
        <button id="runStressTest">Run Stress Test (100 games)</button>
        <button id="stopSimulation" disabled>Stop</button>
        <button id="clearLog">Clear Log</button>
        <button id="resetStats">Reset Stats</button>
    </div>

    <div class="stats">
        <div class="stat-box">
            <div class="stat-label">Games Completed</div>
            <div class="stat-value" id="gamesCompleted">0</div>
        </div>
        <div class="stat-box">
            <div class="stat-label">Player Wins</div>
            <div class="stat-value" id="playerWins">0</div>
        </div>
        <div class="stat-box">
            <div class="stat-label">Computer Wins</div>
            <div class="stat-value" id="computerWins">0</div>
        </div>
        <div class="stat-box">
            <div class="stat-label">Errors Detected</div>
            <div class="stat-value" id="errorsDetected">0</div>
        </div>
        <div class="stat-box">
            <div class="stat-label">Pass Rate</div>
            <div class="stat-value" id="passRate">100%</div>
        </div>
    </div>

    <div id="log"></div>

    <script src="game.js"></script>
    <script>
        class GameSimulator {
            constructor() {
                this.stats = {
                    gamesCompleted: 0,
                    playerWins: 0,
                    computerWins: 0,
                    errorsDetected: 0
                };
                this.running = false;
                this.logElement = document.getElementById('log');
                this.setupControls();
            }

            setupControls() {
                document.getElementById('runSimulation').addEventListener('click', () => {
                    const numGames = parseInt(document.getElementById('numGames').value);
                    const delay = parseInt(document.getElementById('delay').value);
                    this.runSimulation(numGames, delay);
                });

                document.getElementById('runSingleGame').addEventListener('click', () => {
                    this.runSingleGame(true);
                });

                document.getElementById('runStressTest').addEventListener('click', () => {
                    this.runSimulation(100, 0);
                });

                document.getElementById('stopSimulation').addEventListener('click', () => {
                    this.running = false;
                    this.updateControls(false);
                });

                document.getElementById('clearLog').addEventListener('click', () => {
                    this.logElement.innerHTML = '';
                });

                document.getElementById('resetStats').addEventListener('click', () => {
                    this.stats = {
                        gamesCompleted: 0,
                        playerWins: 0,
                        computerWins: 0,
                        errorsDetected: 0
                    };
                    this.updateStats();
                    this.log('Statistics reset.', 'success');
                });
            }

            updateControls(running) {
                document.getElementById('runSimulation').disabled = running;
                document.getElementById('runSingleGame').disabled = running;
                document.getElementById('runStressTest').disabled = running;
                document.getElementById('stopSimulation').disabled = !running;
            }

            updateStats() {
                document.getElementById('gamesCompleted').textContent = this.stats.gamesCompleted;
                document.getElementById('playerWins').textContent = this.stats.playerWins;
                document.getElementById('computerWins').textContent = this.stats.computerWins;
                document.getElementById('errorsDetected').textContent = this.stats.errorsDetected;
                
                // Calculate pass rate
                const passRate = this.stats.gamesCompleted > 0 
                    ? (((this.stats.gamesCompleted - this.stats.errorsDetected) / this.stats.gamesCompleted) * 100).toFixed(1)
                    : 100;
                document.getElementById('passRate').textContent = `${passRate}%`;
            }

            log(message, type = 'normal') {
                const line = document.createElement('div');
                if (type === 'error') line.className = 'error';
                if (type === 'warning') line.className = 'warning';
                if (type === 'success') line.className = 'success';
                if (type === 'separator') line.className = 'game-separator';
                
                line.textContent = message;
                this.logElement.appendChild(line);
                this.logElement.scrollTop = this.logElement.scrollHeight;
            }

            async runSimulation(numGames, delay) {
                this.running = true;
                this.updateControls(true);
                this.log(`Starting simulation of ${numGames} games...`, 'success');
                this.log('', 'separator');

                for (let i = 0; i < numGames && this.running; i++) {
                    this.log(`\n=== GAME ${i + 1} ===`, 'success');
                    await this.runSingleGame(false);
                    
                    if (delay > 0 && i < numGames - 1) {
                        await new Promise(resolve => setTimeout(resolve, delay));
                    }
                }

                if (this.running) {
                    this.log('', 'separator');
                    this.log(`\nüìä SIMULATION SUMMARY`, 'success');
                    this.log(`‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê`, 'success');
                    this.log(`Total Games: ${this.stats.gamesCompleted}`, 'success');
                    this.log(`Player Wins: ${this.stats.playerWins} (${(this.stats.playerWins / this.stats.gamesCompleted * 100).toFixed(1)}%)`, 'success');
                    this.log(`Computer Wins: ${this.stats.computerWins} (${(this.stats.computerWins / this.stats.gamesCompleted * 100).toFixed(1)}%)`, 'success');
                    
                    if (this.stats.errorsDetected === 0) {
                        this.log(`\n‚úÖ ALL TESTS PASSED! No errors detected.`, 'success');
                    } else {
                        this.log(`\n‚ùå ${this.stats.errorsDetected} game(s) with errors`, 'error');
                        const passRate = ((this.stats.gamesCompleted - this.stats.errorsDetected) / this.stats.gamesCompleted * 100).toFixed(1);
                        this.log(`Pass Rate: ${passRate}%`, this.stats.errorsDetected > 0 ? 'error' : 'success');
                    }
                    this.log(`‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n`, 'success');
                }
                
                this.running = false;
                this.updateControls(false);
            }

            async runSingleGame(verbose = true) {
                const game = new CribbageGame();
                const errors = [];
                let turnCount = 0;
                const maxTurns = 200; // Safety limit
                const stateHistory = []; // Track state transitions

                // Capture game messages
                const messages = [];
                game.addMessageListener(msg => {
                    messages.push(msg);
                    if (verbose) this.log(msg);
                });

                // Track previous state for validation
                let previousState = null;
                let previousScores = { player: 0, computer: 0 };
                let roundsPlayed = 0;
                let maxCardsInHand = { player: 0, computer: 0 };

                try {
                    // Cut for deal
                    game.cutForDeal();
                    
                    // Play until game over
                    while (game.state !== 'GAME_OVER' && turnCount < maxTurns) {
                        turnCount++;

                        // Track state transitions
                        if (game.state !== previousState) {
                            stateHistory.push(game.state);
                            previousState = game.state;
                        }

                        // Track max hand size
                        maxCardsInHand.player = Math.max(maxCardsInHand.player, game.player.hand.length);
                        maxCardsInHand.computer = Math.max(maxCardsInHand.computer, game.computer.hand.length);

                        if (game.state === 'CUT_FOR_DEAL') {
                            game.cutForDeal();
                        } else if (game.state === 'DISCARD') {
                            // Auto-discard for both players
                            this.autoDiscard(game);
                        } else if (game.state === 'PLAY') {
                            // Validate scores haven't decreased
                            if (game.player.score < previousScores.player) {
                                errors.push(`Player score decreased from ${previousScores.player} to ${game.player.score}`);
                            }
                            if (game.computer.score < previousScores.computer) {
                                errors.push(`Computer score decreased from ${previousScores.computer} to ${game.computer.score}`);
                            }

                            // Auto-play
                            const played = this.autoPlay(game);
                            if (!played) {
                                // Check for infinite loop
                                if (turnCount > maxTurns - 10) {
                                    errors.push('Possible infinite loop in play phase');
                                    break;
                                }
                            }

                            // Update previous scores
                            previousScores.player = game.player.score;
                            previousScores.computer = game.computer.score;
                        } else if (game.state === 'ROUND_OVER') {
                            roundsPlayed++;
                            game.startRound();
                        }

                        // Validate game state after every action
                        const stateErrors = this.validateGameState(game);
                        if (stateErrors.length > 0) {
                            errors.push(...stateErrors);
                            break;
                        }
                    }

                    if (turnCount >= maxTurns) {
                        errors.push('Game exceeded maximum turn limit');
                    }

                    // ===== POST-GAME VALIDATION =====

                    // Validate final state
                    if (game.state !== 'GAME_OVER' && errors.length === 0) {
                        errors.push('Game did not reach GAME_OVER state');
                    }

                    // Validate a winner exists
                    if (game.state === 'GAME_OVER') {
                        if (game.player.score < 121 && game.computer.score < 121) {
                            errors.push('Game ended but no player reached 121');
                        }
                    }

                    // Validate state transitions make sense
                    const expectedFlow = ['CUT_FOR_DEAL', 'DISCARD', 'PLAY'];
                    const hasExpectedStart = stateHistory.slice(0, 3).every((state, i) => state === expectedFlow[i]);
                    if (!hasExpectedStart) {
                        errors.push(`Unexpected state flow: ${stateHistory.slice(0, 5).join(' -> ')}`);
                    }

                    // Validate max hand size was reasonable
                    if (maxCardsInHand.player > 6 || maxCardsInHand.computer > 6) {
                        errors.push(`Hand size exceeded 6: Player ${maxCardsInHand.player}, Computer ${maxCardsInHand.computer}`);
                    }

                    // Validate at least one round was played
                    if (roundsPlayed === 0 && errors.length === 0) {
                        errors.push('No rounds were completed');
                    }

                    // Record results
                    this.stats.gamesCompleted++;
                    if (game.player.score >= 121) this.stats.playerWins++;
                    if (game.computer.score >= 121) this.stats.computerWins++;

                    if (errors.length > 0) {
                        this.stats.errorsDetected++;
                        this.log(`\n‚ö†Ô∏è ERRORS DETECTED (${errors.length}):`, 'error');
                        errors.forEach(err => this.log(`  - ${err}`, 'error'));
                        
                        // Log diagnostic info
                        this.log(`\nDiagnostics:`, 'warning');
                        this.log(`  State: ${game.state}`, 'warning');
                        this.log(`  Scores: Player ${game.player.score}, Computer ${game.computer.score}`, 'warning');
                        this.log(`  Rounds played: ${roundsPlayed}`, 'warning');
                        this.log(`  Turn count: ${turnCount}`, 'warning');
                        this.log(`  State history: ${stateHistory.slice(0, 10).join(' -> ')}`, 'warning');
                    } else if (verbose) {
                        this.log(`‚úì Game completed successfully!`, 'success');
                        this.log(`  Rounds played: ${roundsPlayed}`, 'success');
                    }

                    this.log(`Final: Player ${game.player.score}, Computer ${game.computer.score}`, 'success');

                } catch (error) {
                    this.stats.errorsDetected++;
                    this.log(`\nüí• EXCEPTION: ${error.message}`, 'error');
                    this.log(`  Stack: ${error.stack}`, 'error');
                    console.error(error);
                }

                this.updateStats();
            }

            autoDiscard(game) {
                // Simple strategy: discard first 2 cards for player
                const playerIndices = [0, 1];
                game.discardToCrib(playerIndices);
            }

            autoPlay(game) {
                const currentPlayer = game.currentTurn;
                
                // Get playable cards
                const playableCards = currentPlayer.hand.filter(card =>
                    !currentPlayer.playedCards.includes(card) &&
                    game.currentCount + card.value <= 31
                );

                if (playableCards.length > 0) {
                    // Play first playable card
                    game.playCard(currentPlayer, playableCards[0]);
                    return true;
                } else {
                    // Say go
                    game.sayGo();
                    return false;
                }
            }

            validateGameState(game) {
                const errors = [];

                // ===== SCORE VALIDATION =====
                
                // Check for negative scores
                if (game.player.score < 0 || game.computer.score < 0) {
                    errors.push('Negative score detected');
                }

                // CRITICAL: Check that both players don't have 121+ (game should end when first reaches 121)
                if (game.player.score >= 121 && game.computer.score >= 121) {
                    errors.push(`CRITICAL: Both players at 121+: Player ${game.player.score}, Computer ${game.computer.score}`);
                }

                // Check if game is over when someone has 121+
                if ((game.player.score >= 121 || game.computer.score >= 121) && game.state !== 'GAME_OVER') {
                    errors.push(`Game not ended despite score >= 121: Player ${game.player.score}, Computer ${game.computer.score}`);
                }

                // Check for unreasonably high scores (sanity check)
                if (game.player.score > 200 || game.computer.score > 200) {
                    errors.push(`Unreasonably high score: Player ${game.player.score}, Computer ${game.computer.score}`);
                }

                // ===== COUNT VALIDATION =====
                
                // Check count is valid (0-31)
                if (game.currentCount < 0 || game.currentCount > 31) {
                    errors.push(`Invalid count: ${game.currentCount}`);
                }

                // Validate played pile cards match count
                if (game.playedPile.length > 0) {
                    const calculatedCount = game.playedPile.reduce((sum, p) => sum + p.card.value, 0);
                    if (calculatedCount !== game.currentCount) {
                        errors.push(`Count mismatch: calculated ${calculatedCount}, actual ${game.currentCount}`);
                    }
                }

                // Count should be 0 if no cards in played pile
                if (game.playedPile.length === 0 && game.currentCount !== 0 && game.state === 'PLAY') {
                    errors.push(`Count is ${game.currentCount} but no cards in played pile`);
                }

                // ===== CARD COUNT VALIDATION =====
                
                // Check hand sizes during discard phase (should be 6 each)
                if (game.state === 'DISCARD') {
                    if (game.player.hand.length !== 6) {
                        errors.push(`Player has ${game.player.hand.length} cards during discard (should be 6)`);
                    }
                    if (game.computer.hand.length !== 6) {
                        errors.push(`Computer has ${game.computer.hand.length} cards during discard (should be 6)`);
                    }
                }

                // Check hand sizes during play phase (should be 4 total per player)
                if (game.state === 'PLAY') {
                    const playerTotal = game.player.hand.length + game.player.playedCards.length;
                    const computerTotal = game.computer.hand.length + game.computer.playedCards.length;
                    
                    if (playerTotal !== 4) {
                        errors.push(`Player card count: ${playerTotal} (should be 4)`);
                    }
                    if (computerTotal !== 4) {
                        errors.push(`Computer card count: ${computerTotal} (should be 4)`);
                    }
                }

                // Crib should have exactly 4 cards during play
                if (game.state === 'PLAY' && game.crib.length !== 4) {
                    errors.push(`Crib has ${game.crib.length} cards (should be 4)`);
                }

                // Check no duplicate cards in play
                if (game.state === 'PLAY') {
                    const allCards = [
                        ...game.player.hand,
                        ...game.player.playedCards,
                        ...game.computer.hand,
                        ...game.computer.playedCards,
                        ...game.crib
                    ];
                    
                    if (game.cutCard) allCards.push(game.cutCard);
                    
                    // Should have 13 cards total (4+4+4+1 cut)
                    if (allCards.length !== 13) {
                        errors.push(`Total cards in play: ${allCards.length} (should be 13)`);
                    }
                }

                // ===== TURN MANAGEMENT =====
                
                // Check that currentTurn is set during play
                if (game.state === 'PLAY' && !game.currentTurn) {
                    errors.push('No current turn set during play phase');
                }

                // Check that currentTurn is valid
                if (game.currentTurn && game.currentTurn !== game.player && game.currentTurn !== game.computer) {
                    errors.push('Invalid currentTurn value');
                }

                // ===== DEALER VALIDATION =====
                
                // Check that dealer is set when it should be
                if (['DISCARD', 'PLAY', 'ROUND_OVER'].includes(game.state) && !game.dealer) {
                    errors.push(`No dealer set during ${game.state}`);
                }

                // Check dealer is valid
                if (game.dealer && game.dealer !== game.player && game.dealer !== game.computer) {
                    errors.push('Invalid dealer value');
                }

                // ===== STATE VALIDATION =====
                
                // Check valid game states
                const validStates = ['CUT_FOR_DEAL', 'DISCARD', 'PLAY', 'ROUND_OVER', 'GAME_OVER'];
                if (!validStates.includes(game.state)) {
                    errors.push(`Invalid game state: ${game.state}`);
                }

                // Check played pile doesn't exceed 8 cards (4 from each player)
                if (game.playedPile.length > 8) {
                    errors.push(`Played pile has ${game.playedPile.length} cards (max should be 8)`);
                }

                // ===== CUT CARD VALIDATION =====
                
                // Cut card should be set during play
                if (game.state === 'PLAY' && !game.cutCard) {
                    errors.push('No cut card during play phase');
                }

                return errors;
            }
        }

        // Initialize simulator
        const simulator = new GameSimulator();
        simulator.log('Game simulator ready. Click "Run Simulation" to test multiple games.', 'success');
    </script>
</body>
</html>
