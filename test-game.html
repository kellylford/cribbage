<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Cribbage Game Simulator</title>
    <style>
        body {
            font-family: 'Courier New', monospace;
            max-width: 1200px;
            margin: 20px auto;
            padding: 20px;
            background-color: #1e1e1e;
            color: #d4d4d4;
        }
        h1 {
            color: #4ec9b0;
        }
        .controls {
            margin: 20px 0;
            padding: 15px;
            background-color: #2d2d2d;
            border-radius: 5px;
        }
        button {
            padding: 10px 20px;
            margin: 5px;
            background-color: #0e639c;
            color: white;
            border: none;
            border-radius: 3px;
            cursor: pointer;
            font-size: 14px;
        }
        button:hover {
            background-color: #1177bb;
        }
        button:disabled {
            background-color: #3e3e3e;
            cursor: not-allowed;
        }
        .stats {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin: 20px 0;
        }
        .stat-box {
            background-color: #2d2d2d;
            padding: 15px;
            border-radius: 5px;
            border-left: 4px solid #4ec9b0;
        }
        .stat-label {
            color: #808080;
            font-size: 12px;
            text-transform: uppercase;
        }
        .stat-value {
            font-size: 24px;
            font-weight: bold;
            color: #4ec9b0;
            margin-top: 5px;
        }
        #log {
            background-color: #2d2d2d;
            padding: 15px;
            border-radius: 5px;
            height: 500px;
            overflow-y: auto;
            font-size: 13px;
            line-height: 1.5;
        }
        .error {
            color: #f48771;
            font-weight: bold;
        }
        .warning {
            color: #dcdcaa;
        }
        .success {
            color: #4ec9b0;
        }
        .game-separator {
            border-top: 2px solid #4ec9b0;
            margin: 15px 0;
            padding-top: 10px;
        }
        .input-group {
            margin: 10px 0;
        }
        .input-group label {
            display: inline-block;
            width: 150px;
            color: #9cdcfe;
        }
        .input-group input {
            padding: 5px 10px;
            background-color: #3c3c3c;
            border: 1px solid #555;
            color: #d4d4d4;
            border-radius: 3px;
            width: 100px;
        }
    </style>
</head>
<body>
    <h1>üÉè Cribbage Game Simulator & Tester</h1>
    
    <div class="controls">
        <h3 style="margin-top: 0; color: #9cdcfe;">Test Coverage</h3>
        <p style="font-size: 12px; color: #808080; margin: 10px 0;">
            This comprehensive test suite validates:<br>
            <strong>Game Flow:</strong><br>
            ‚úì Both players can't reach 121+ (game ends at first 121)<br>
            ‚úì State transitions valid (CUT ‚Üí DISCARD ‚Üí PLAY ‚Üí scoring)<br>
            ‚úì Game reaches GAME_OVER with winner at 121+<br>
            ‚úì At least one round played per game<br>
            <strong>Scoring Rules:</strong><br>
            ‚úì No impossible hand/crib scores (19, 25, 26, 27, >29)<br>
            ‚úì Pair scoring = 2 points (exactly)<br>
            ‚úì Three of a kind = 6 points (exactly)<br>
            ‚úì Four of a kind = 12 points (exactly)<br>
            ‚úì Fifteen = 2 points (exactly)<br>
            ‚úì Thirty-one = 2 points (exactly)<br>
            ‚úì Run length 3-7 only, points = length<br>
            ‚úì His heels (2 pts) only once per round<br>
            ‚úì Pegging scores reasonable (<28 per round)<br>
            <strong>Card Management:</strong><br>
            ‚úì Card counts correct (6 dealt, 4 after discard, 4 in crib)<br>
            ‚úì No duplicate cards in play (13 unique cards)<br>
            ‚úì Played pile cards belong to players<br>
            ‚úì Count stays 0-31, resets properly after "go"<br>
            ‚úì Played pile count matches current count<br>
            <strong>Turn & State:</strong><br>
            ‚úì Turn management (correct player's turn)<br>
            ‚úì Dealer assignment and rotation<br>
            ‚úì Cut card exists during play<br>
            ‚úì Scores never decrease<br>
        </p>
        <div class="input-group">
            <label for="numGames">Number of games:</label>
            <input type="number" id="numGames" value="10" min="1" max="1000">
        </div>
        <div class="input-group">
            <label for="delay">Delay (ms):</label>
            <input type="number" id="delay" value="0" min="0" max="1000">
        </div>
        <button id="runSimulation">Run Simulation</button>
        <button id="runSingleGame">Run Single Game</button>
        <button id="runStressTest">Run Stress Test (100 games)</button>
        <button id="stopSimulation" disabled>Stop</button>
        <button id="clearLog">Clear Log</button>
        <button id="resetStats">Reset Stats</button>
    </div>

    <div class="stats">
        <div class="stat-box">
            <div class="stat-label">Games Completed</div>
            <div class="stat-value" id="gamesCompleted">0</div>
        </div>
        <div class="stat-box">
            <div class="stat-label">Player Wins</div>
            <div class="stat-value" id="playerWins">0</div>
        </div>
        <div class="stat-box">
            <div class="stat-label">Computer Wins</div>
            <div class="stat-value" id="computerWins">0</div>
        </div>
        <div class="stat-box">
            <div class="stat-label">Errors Detected</div>
            <div class="stat-value" id="errorsDetected">0</div>
        </div>
        <div class="stat-box">
            <div class="stat-label">Pass Rate</div>
            <div class="stat-value" id="passRate">100%</div>
        </div>
    </div>

    <div id="log"></div>

    <script src="game.js"></script>
    <script>
        class GameSimulator {
            constructor() {
                this.stats = {
                    gamesCompleted: 0,
                    playerWins: 0,
                    computerWins: 0,
                    errorsDetected: 0
                };
                this.detailedStats = {
                    highestHand: { score: 0, player: '', cards: '', game: 0 },
                    highestCrib: { score: 0, player: '', cards: '', game: 0 },
                    highestPegging: { score: 0, player: '', game: 0, round: 0 },
                    totalRounds: 0,
                    shortestGame: { rounds: Infinity, score: '', game: 0 },
                    longestGame: { rounds: 0, score: '', game: 0 },
                    highestScore: { score: 0, player: '', game: 0 },
                    closestGame: { diff: Infinity, score: '', game: 0 },
                    perfectHands: 0, // 29 point hands
                    skunkGames: 0, // Winner >= 121, loser < 91
                    doubleSkunkGames: 0, // Winner >= 121, loser < 61
                    totalCardsPlayed: 0,
                    goPoints: 0,
                    fifteenPoints: 0,
                    pairPoints: 0,
                    runPoints: 0
                };
                this.running = false;
                this.logElement = document.getElementById('log');
                this.setupControls();
            }

            setupControls() {
                document.getElementById('runSimulation').addEventListener('click', () => {
                    const numGames = parseInt(document.getElementById('numGames').value);
                    const delay = parseInt(document.getElementById('delay').value);
                    this.runSimulation(numGames, delay);
                });

                document.getElementById('runSingleGame').addEventListener('click', () => {
                    this.runSingleGame(true);
                });

                document.getElementById('runStressTest').addEventListener('click', () => {
                    this.runSimulation(100, 0);
                });

                document.getElementById('stopSimulation').addEventListener('click', () => {
                    this.running = false;
                    this.updateControls(false);
                });

                document.getElementById('clearLog').addEventListener('click', () => {
                    this.logElement.innerHTML = '';
                });

                document.getElementById('resetStats').addEventListener('click', () => {
                    this.stats = {
                        gamesCompleted: 0,
                        playerWins: 0,
                        computerWins: 0,
                        errorsDetected: 0
                    };
                    this.detailedStats = {
                        highestHand: { score: 0, player: '', cards: '', game: 0 },
                        highestCrib: { score: 0, player: '', cards: '', game: 0 },
                        highestPegging: { score: 0, player: '', game: 0, round: 0 },
                        totalRounds: 0,
                        shortestGame: { rounds: Infinity, score: '', game: 0 },
                        longestGame: { rounds: 0, score: '', game: 0 },
                        highestScore: { score: 0, player: '', game: 0 },
                        closestGame: { diff: Infinity, score: '', game: 0 },
                        perfectHands: 0,
                        skunkGames: 0,
                        doubleSkunkGames: 0,
                        totalCardsPlayed: 0,
                        goPoints: 0,
                        fifteenPoints: 0,
                        pairPoints: 0,
                        runPoints: 0
                    };
                    this.updateStats();
                    this.log('Statistics reset.', 'success');
                });
            }

            updateControls(running) {
                document.getElementById('runSimulation').disabled = running;
                document.getElementById('runSingleGame').disabled = running;
                document.getElementById('runStressTest').disabled = running;
                document.getElementById('stopSimulation').disabled = !running;
            }

            updateStats() {
                document.getElementById('gamesCompleted').textContent = this.stats.gamesCompleted;
                document.getElementById('playerWins').textContent = this.stats.playerWins;
                document.getElementById('computerWins').textContent = this.stats.computerWins;
                document.getElementById('errorsDetected').textContent = this.stats.errorsDetected;
                
                // Calculate pass rate
                const passRate = this.stats.gamesCompleted > 0 
                    ? (((this.stats.gamesCompleted - this.stats.errorsDetected) / this.stats.gamesCompleted) * 100).toFixed(1)
                    : 100;
                document.getElementById('passRate').textContent = `${passRate}%`;
            }

            log(message, type = 'normal') {
                const line = document.createElement('div');
                if (type === 'error') line.className = 'error';
                if (type === 'warning') line.className = 'warning';
                if (type === 'success') line.className = 'success';
                if (type === 'separator') line.className = 'game-separator';
                
                line.textContent = message;
                this.logElement.appendChild(line);
                this.logElement.scrollTop = this.logElement.scrollHeight;
            }

            async runSimulation(numGames, delay) {
                this.running = true;
                this.updateControls(true);
                this.log(`Starting simulation of ${numGames} games...`, 'success');
                this.log('', 'separator');

                for (let i = 0; i < numGames && this.running; i++) {
                    // Only log game headers every 10 games to reduce DOM overhead
                    if ((i + 1) % 10 === 0 || i === 0) {
                        this.log(`\nGames ${i + 1 - 9}-${i + 1}...`, 'success');
                    }
                    
                    await this.runSingleGame(false);
                    
                    // Give browser time to update UI every 10 games or if delay is set
                    if (delay > 0 || (i + 1) % 10 === 0) {
                        await new Promise(resolve => setTimeout(resolve, delay || 0));
                    }
                }

                if (this.running) {
                    this.log('', 'separator');
                    this.log(`\nüìä SIMULATION SUMMARY`, 'success');
                    this.log(`‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê`, 'success');
                    this.log(`Total Games: ${this.stats.gamesCompleted}`, 'success');
                    this.log(`Player Wins: ${this.stats.playerWins} (${(this.stats.playerWins / this.stats.gamesCompleted * 100).toFixed(1)}%)`, 'success');
                    this.log(`Computer Wins: ${this.stats.computerWins} (${(this.stats.computerWins / this.stats.gamesCompleted * 100).toFixed(1)}%)`, 'success');
                    
                    if (this.stats.errorsDetected === 0) {
                        this.log(`\n‚úÖ ALL TESTS PASSED! No errors detected.`, 'success');
                    } else {
                        this.log(`\n‚ùå ${this.stats.errorsDetected} game(s) with errors`, 'error');
                        const passRate = ((this.stats.gamesCompleted - this.stats.errorsDetected) / this.stats.gamesCompleted * 100).toFixed(1);
                        this.log(`Pass Rate: ${passRate}%`, this.stats.errorsDetected > 0 ? 'error' : 'success');
                    }
                    
                    // Detailed Statistics
                    this.log(`\nüìà DETAILED STATISTICS`, 'success');
                    this.log(`‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê`, 'success');
                    
                    const ds = this.detailedStats;
                    const avgRounds = ds.totalRounds / this.stats.gamesCompleted;
                    
                    this.log(`\nüéØ Scoring Records:`, 'success');
                    if (ds.highestHand.score > 0) {
                        this.log(`  Highest Hand: ${ds.highestHand.score} points (${ds.highestHand.player}, Game ${ds.highestHand.game})`, 'success');
                        if (ds.highestHand.cards) this.log(`    Cards: ${ds.highestHand.cards}`, 'success');
                    }
                    if (ds.highestCrib.score > 0) {
                        this.log(`  Highest Crib: ${ds.highestCrib.score} points (${ds.highestCrib.player}, Game ${ds.highestCrib.game})`, 'success');
                        if (ds.highestCrib.cards) this.log(`    Cards: ${ds.highestCrib.cards}`, 'success');
                    }
                    if (ds.highestPegging.score > 0) {
                        this.log(`  Most Pegging in One Round: ${ds.highestPegging.score} points (${ds.highestPegging.player}, Game ${ds.highestPegging.game})`, 'success');
                    }
                    if (ds.perfectHands > 0) {
                        this.log(`  Perfect 29-point hands: ${ds.perfectHands}`, 'success');
                    }
                    
                    this.log(`\nüìè Game Length:`, 'success');
                    this.log(`  Average rounds per game: ${avgRounds.toFixed(1)}`, 'success');
                    if (ds.shortestGame.rounds < Infinity) {
                        this.log(`  Shortest game: ${ds.shortestGame.rounds} rounds (${ds.shortestGame.score}, Game ${ds.shortestGame.game})`, 'success');
                    }
                    if (ds.longestGame.rounds > 0) {
                        this.log(`  Longest game: ${ds.longestGame.rounds} rounds (${ds.longestGame.score}, Game ${ds.longestGame.game})`, 'success');
                    }
                    
                    this.log(`\nüèÜ Score Analysis:`, 'success');
                    if (ds.highestScore.score > 0) {
                        this.log(`  Highest final score: ${ds.highestScore.score} (${ds.highestScore.player}, Game ${ds.highestScore.game})`, 'success');
                    }
                    if (ds.closestGame.diff < Infinity) {
                        this.log(`  Closest game: ${ds.closestGame.diff} point difference (${ds.closestGame.score}, Game ${ds.closestGame.game})`, 'success');
                    }
                    if (ds.skunkGames > 0) {
                        this.log(`  Skunks (loser < 91): ${ds.skunkGames} (${(ds.skunkGames / this.stats.gamesCompleted * 100).toFixed(1)}%)`, 'success');
                    }
                    if (ds.doubleSkunkGames > 0) {
                        this.log(`  Double Skunks (loser < 61): ${ds.doubleSkunkGames} (${(ds.doubleSkunkGames / this.stats.gamesCompleted * 100).toFixed(1)}%)`, 'success');
                    }
                    
                    this.log(`\nüé¥ Play Statistics:`, 'success');
                    const avgCards = ds.totalCardsPlayed / this.stats.gamesCompleted;
                    this.log(`  Average cards played per game: ${avgCards.toFixed(1)}`, 'success');
                    
                    this.log(`‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n`, 'success');
                }
                
                this.running = false;
                this.updateControls(false);
            }

            async runSingleGame(verbose = true) {
                const game = new CribbageGame();
                const errors = [];
                let loopCount = 0;
                const maxLoops = 200; // Safety limit to prevent infinite loops
                const stateHistory = []; // Track state transitions

                // Capture game messages
                const messages = [];
                game.addMessageListener(msg => {
                    messages.push(msg);
                    if (verbose) this.log(msg);
                });

                // Track previous state for validation
                let previousState = null;
                let previousScores = { player: 0, computer: 0 };
                let roundsPlayed = 0;
                let maxCardsInHand = { player: 0, computer: 0 };
                let totalPlays = 0; // Count actual card plays
                let peggingScoresThisRound = { player: 0, computer: 0 };
                let roundStartScores = { player: 0, computer: 0 };

                try {
                    // Cut for deal
                    game.cutForDeal();
                    
                    // Play until game over
                    while (game.state !== 'GAME_OVER' && loopCount < maxLoops) {
                        loopCount++;

                        // Track state transitions
                        if (game.state !== previousState) {
                            stateHistory.push(game.state);
                            previousState = game.state;
                        }

                        // Track max hand size
                        maxCardsInHand.player = Math.max(maxCardsInHand.player, game.player.hand.length);
                        maxCardsInHand.computer = Math.max(maxCardsInHand.computer, game.computer.hand.length);

                        if (game.state === 'CUT_FOR_DEAL') {
                            game.cutForDeal();
                        } else if (game.state === 'DISCARD') {
                            // Auto-discard for both players
                            this.autoDiscard(game);
                        } else if (game.state === 'PLAY') {
                            // Track when we enter play phase for pegging validation
                            if (previousState === 'DISCARD') {
                                roundStartScores = { player: game.player.score, computer: game.computer.score };
                                peggingScoresThisRound = { player: 0, computer: 0 };
                            }
                            
                            // Validate scores haven't decreased
                            if (game.player.score < previousScores.player) {
                                errors.push(`Player score decreased from ${previousScores.player} to ${game.player.score}`);
                            }
                            if (game.computer.score < previousScores.computer) {
                                errors.push(`Computer score decreased from ${previousScores.computer} to ${game.computer.score}`);
                            }

                            // Track pegging scores during play
                            peggingScoresThisRound.player = game.player.score - roundStartScores.player;
                            peggingScoresThisRound.computer = game.computer.score - roundStartScores.computer;
                            
                            // Validate pegging scores are reasonable (max ~24 in one round: 8 cards * 3 avg)
                            if (peggingScoresThisRound.player > 28) {
                                errors.push(`Excessive pegging: Player scored ${peggingScoresThisRound.player} during play (max realistic ~28)`);
                            }
                            if (peggingScoresThisRound.computer > 28) {
                                errors.push(`Excessive pegging: Computer scored ${peggingScoresThisRound.computer} during play (max realistic ~28)`);
                            }

                            // Auto-play
                            const played = this.autoPlay(game);
                            if (!played) {
                                // Check for infinite loop
                                if (loopCount > maxLoops - 10) {
                                    errors.push('Possible infinite loop in play phase');
                                    break;
                                }
                            } else {
                                totalPlays++;
                            }

                            // Update previous scores
                            previousScores.player = game.player.score;
                            previousScores.computer = game.computer.score;
                        } else if (game.state === 'ROUND_OVER') {
                            roundsPlayed++;
                            game.startRound();
                        }

                        // Validate game state (only check critical items every loop, full validation less frequently)
                        const stateErrors = loopCount % 5 === 0 
                            ? this.validateGameState(game)  // Full validation every 5 loops
                            : this.validateCriticalState(game);  // Quick critical checks every loop
                        
                        if (stateErrors.length > 0) {
                            errors.push(...stateErrors);
                            break;
                        }
                    }

                    if (loopCount >= maxLoops) {
                        errors.push('Game exceeded maximum loop limit');
                    }

                    // ===== POST-GAME VALIDATION =====

                    // Validate final state
                    if (game.state !== 'GAME_OVER' && errors.length === 0) {
                        errors.push('Game did not reach GAME_OVER state');
                    }

                    // Validate a winner exists
                    if (game.state === 'GAME_OVER') {
                        if (game.player.score < 121 && game.computer.score < 121) {
                            errors.push('Game ended but no player reached 121');
                        }
                    }

                    // Validate state transitions make sense
                    // Normal flow is: DISCARD -> PLAY -> ROUND_OVER -> DISCARD -> PLAY... or GAME_OVER
                    // (CUT_FOR_DEAL happens before tracking starts)
                    const validTransitions = {
                        'DISCARD': ['PLAY'],
                        'PLAY': ['ROUND_OVER', 'GAME_OVER'],
                        'ROUND_OVER': ['DISCARD', 'GAME_OVER'],
                        'CUT_FOR_DEAL': ['DISCARD', 'CUT_FOR_DEAL']  // Can retry on tie
                    };
                    
                    for (let i = 0; i < stateHistory.length - 1; i++) {
                        const current = stateHistory[i];
                        const next = stateHistory[i + 1];
                        const allowedNext = validTransitions[current];
                        
                        if (allowedNext && !allowedNext.includes(next)) {
                            errors.push(`Invalid state transition: ${current} -> ${next}`);
                            break;
                        }
                    }

                    // Validate max hand size was reasonable
                    if (maxCardsInHand.player > 6 || maxCardsInHand.computer > 6) {
                        errors.push(`Hand size exceeded 6: Player ${maxCardsInHand.player}, Computer ${maxCardsInHand.computer}`);
                    }

                    // Validate at least one round was played
                    if (roundsPlayed === 0 && errors.length === 0) {
                        errors.push('No rounds were completed');
                    }

                    // Record results
                    this.stats.gamesCompleted++;
                    if (game.player.score >= 121) this.stats.playerWins++;
                    if (game.computer.score >= 121) this.stats.computerWins++;

                    // Update detailed statistics
                    const gameNum = this.stats.gamesCompleted;
                    this.detailedStats.totalRounds += roundsPlayed;
                    this.detailedStats.totalCardsPlayed += totalPlays;
                    
                    // Game length records
                    if (roundsPlayed < this.detailedStats.shortestGame.rounds) {
                        this.detailedStats.shortestGame = {
                            rounds: roundsPlayed,
                            score: `${game.player.score}-${game.computer.score}`,
                            game: gameNum
                        };
                    }
                    if (roundsPlayed > this.detailedStats.longestGame.rounds) {
                        this.detailedStats.longestGame = {
                            rounds: roundsPlayed,
                            score: `${game.player.score}-${game.computer.score}`,
                            game: gameNum
                        };
                    }
                    
                    // Score records
                    const maxScore = Math.max(game.player.score, game.computer.score);
                    if (maxScore > this.detailedStats.highestScore.score) {
                        this.detailedStats.highestScore = {
                            score: maxScore,
                            player: game.player.score > game.computer.score ? 'Player' : 'Computer',
                            game: gameNum
                        };
                    }
                    
                    // Closest game
                    const scoreDiff = Math.abs(game.player.score - game.computer.score);
                    if (scoreDiff < this.detailedStats.closestGame.diff) {
                        this.detailedStats.closestGame = {
                            diff: scoreDiff,
                            score: `${game.player.score}-${game.computer.score}`,
                            game: gameNum
                        };
                    }
                    
                    // Skunk detection
                    const winner = game.player.score >= 121 ? game.player.score : game.computer.score;
                    const loser = game.player.score >= 121 ? game.computer.score : game.player.score;
                    if (winner >= 121 && loser < 91) {
                        this.detailedStats.skunkGames++;
                        if (loser < 61) {
                            this.detailedStats.doubleSkunkGames++;
                        }
                    }
                    
                    // Parse messages for hand/crib scores (this is approximate since we'd need to instrument the game)
                    // For now, we'll track what we can from the messages
                    this.trackScoringFromMessages(messages, gameNum);

                    if (errors.length > 0) {
                        this.stats.errorsDetected++;
                        this.log(`\n‚ö†Ô∏è GAME ${gameNum} ERRORS (${errors.length}):`, 'error');
                        errors.forEach(err => this.log(`  - ${err}`, 'error'));
                        
                        // Log diagnostic info
                        this.log(`\nDiagnostics:`, 'warning');
                        this.log(`  State: ${game.state}`, 'warning');
                        this.log(`  Scores: Player ${game.player.score}, Computer ${game.computer.score}`, 'warning');
                        this.log(`  Rounds played: ${roundsPlayed}`, 'warning');
                        this.log(`  Cards played: ${totalPlays}`, 'warning');
                        this.log(`  Avg cards/round: ${roundsPlayed > 0 ? (totalPlays / roundsPlayed).toFixed(1) : 'N/A'}`, 'warning');
                        this.log(`  State history: ${stateHistory.slice(0, 10).join(' -> ')}`, 'warning');
                    } else if (verbose) {
                        this.log(`‚úì Game completed successfully!`, 'success');
                        this.log(`  Rounds played: ${roundsPlayed}`, 'success');
                        this.log(`  Cards played: ${totalPlays}`, 'success');
                        this.log(`  Avg cards/round: ${(totalPlays / roundsPlayed).toFixed(1)}`, 'success');
                    }

                    if (verbose) {
                        this.log(`Final: Player ${game.player.score}, Computer ${game.computer.score}`, 'success');
                    }

                } catch (error) {
                    this.stats.errorsDetected++;
                    this.log(`\nüí• EXCEPTION: ${error.message}`, 'error');
                    this.log(`  Stack: ${error.stack}`, 'error');
                    console.error(error);
                }

                this.updateStats();
            }

            autoDiscard(game) {
                // Simple strategy: discard first 2 cards for player
                const playerIndices = [0, 1];
                game.discardToCrib(playerIndices);
            }

            autoPlay(game) {
                const currentPlayer = game.currentTurn;
                
                // Get playable cards
                const playableCards = currentPlayer.hand.filter(card =>
                    !currentPlayer.playedCards.includes(card) &&
                    game.currentCount + card.value <= 31
                );

                if (playableCards.length > 0) {
                    // Play first playable card
                    game.playCard(currentPlayer, playableCards[0]);
                    return true;
                } else {
                    // Say go
                    game.sayGo();
                    return false;
                }
            }

            validateCriticalState(game) {
                // Fast validation - only check the most critical items
                const errors = [];

                // Check for negative or impossible scores
                if (game.player.score < 0 || game.computer.score < 0) {
                    errors.push('Negative score detected');
                }

                // CRITICAL: Both players at 121+
                if (game.player.score >= 121 && game.computer.score >= 121) {
                    errors.push(`CRITICAL: Both players at 121+`);
                }

                // Count validation (most common bug source)
                if (game.currentCount < 0 || game.currentCount > 31) {
                    errors.push(`Invalid count: ${game.currentCount}`);
                }

                // Valid state
                const validStates = ['CUT_FOR_DEAL', 'DISCARD', 'PLAY', 'ROUND_OVER', 'GAME_OVER'];
                if (!validStates.includes(game.state)) {
                    errors.push(`Invalid game state: ${game.state}`);
                }

                return errors;
            }

            validateGameState(game) {
                const errors = [];

                // ===== SCORE VALIDATION =====
                
                // Check for negative scores
                if (game.player.score < 0 || game.computer.score < 0) {
                    errors.push('Negative score detected');
                }

                // CRITICAL: Check that both players don't have 121+ (game should end when first reaches 121)
                if (game.player.score >= 121 && game.computer.score >= 121) {
                    errors.push(`CRITICAL: Both players at 121+: Player ${game.player.score}, Computer ${game.computer.score}`);
                }

                // Check if game is over when someone has 121+
                if ((game.player.score >= 121 || game.computer.score >= 121) && game.state !== 'GAME_OVER') {
                    errors.push(`Game not ended despite score >= 121: Player ${game.player.score}, Computer ${game.computer.score}`);
                }

                // Check for unreasonably high scores (sanity check)
                if (game.player.score > 200 || game.computer.score > 200) {
                    errors.push(`Unreasonably high score: Player ${game.player.score}, Computer ${game.computer.score}`);
                }

                // ===== COUNT VALIDATION =====
                
                // Check count is valid (0-31)
                if (game.currentCount < 0 || game.currentCount > 31) {
                    errors.push(`Invalid count: ${game.currentCount}`);
                }

                // Validate played pile cards match count
                if (game.playedPile.length > 0) {
                    const calculatedCount = game.playedPile.reduce((sum, p) => sum + p.card.value, 0);
                    if (calculatedCount !== game.currentCount) {
                        errors.push(`Count mismatch: calculated ${calculatedCount}, actual ${game.currentCount}`);
                    }
                }

                // Count should be 0 if no cards in played pile
                if (game.playedPile.length === 0 && game.currentCount !== 0 && game.state === 'PLAY') {
                    errors.push(`Count is ${game.currentCount} but no cards in played pile`);
                }

                // ===== CARD COUNT VALIDATION =====
                
                // Check hand sizes during discard phase (should be 6 each)
                if (game.state === 'DISCARD') {
                    if (game.player.hand.length !== 6) {
                        errors.push(`Player has ${game.player.hand.length} cards during discard (should be 6)`);
                    }
                    if (game.computer.hand.length !== 6) {
                        errors.push(`Computer has ${game.computer.hand.length} cards during discard (should be 6)`);
                    }
                }

                // Check hand sizes during play phase (should be 4 total per player)
                if (game.state === 'PLAY') {
                    const playerTotal = game.player.hand.length + game.player.playedCards.length;
                    const computerTotal = game.computer.hand.length + game.computer.playedCards.length;
                    
                    if (playerTotal !== 4) {
                        errors.push(`Player card count: ${playerTotal} (should be 4)`);
                    }
                    if (computerTotal !== 4) {
                        errors.push(`Computer card count: ${computerTotal} (should be 4)`);
                    }
                }

                // Crib should have exactly 4 cards during play
                if (game.state === 'PLAY' && game.crib.length !== 4) {
                    errors.push(`Crib has ${game.crib.length} cards (should be 4)`);
                }

                // Check no duplicate cards in play
                if (game.state === 'PLAY') {
                    const allCards = [
                        ...game.player.hand,
                        ...game.player.playedCards,
                        ...game.computer.hand,
                        ...game.computer.playedCards,
                        ...game.crib
                    ];
                    
                    if (game.cutCard) allCards.push(game.cutCard);
                    
                    // Should have 13 cards total (4+4+4+1 cut)
                    if (allCards.length !== 13) {
                        errors.push(`Total cards in play: ${allCards.length} (should be 13)`);
                    }
                }

                // ===== TURN MANAGEMENT =====
                
                // Check that currentTurn is set during play
                if (game.state === 'PLAY' && !game.currentTurn) {
                    errors.push('No current turn set during play phase');
                }

                // Check that currentTurn is valid
                if (game.currentTurn && game.currentTurn !== game.player && game.currentTurn !== game.computer) {
                    errors.push('Invalid currentTurn value');
                }

                // ===== DEALER VALIDATION =====
                
                // Check that dealer is set when it should be
                if (['DISCARD', 'PLAY', 'ROUND_OVER'].includes(game.state) && !game.dealer) {
                    errors.push(`No dealer set during ${game.state}`);
                }

                // Check dealer is valid
                if (game.dealer && game.dealer !== game.player && game.dealer !== game.computer) {
                    errors.push('Invalid dealer value');
                }

                // ===== STATE VALIDATION =====
                
                // Check valid game states
                const validStates = ['CUT_FOR_DEAL', 'DISCARD', 'PLAY', 'ROUND_OVER', 'GAME_OVER'];
                if (!validStates.includes(game.state)) {
                    errors.push(`Invalid game state: ${game.state}`);
                }

                // Check played pile doesn't exceed 8 cards (4 from each player)
                if (game.playedPile.length > 8) {
                    errors.push(`Played pile has ${game.playedPile.length} cards (max should be 8)`);
                }

                // ===== CUT CARD VALIDATION =====
                
                // Cut card should be set during play
                if (game.state === 'PLAY' && !game.cutCard) {
                    errors.push('No cut card during play phase');
                }

                // ===== PLAY MECHANICS VALIDATION =====
                
                // Validate no player can play when they said they couldn't
                if (game.state === 'PLAY' && game.playedPile.length > 0) {
                    // Check that cards in played pile are unique
                    const playedCardIds = game.playedPile.map(p => `${p.card.rank}${p.card.suit}`);
                    const uniquePlayedCards = new Set(playedCardIds);
                    if (playedCardIds.length !== uniquePlayedCards.size) {
                        errors.push('Duplicate card played in same sequence');
                    }
                    
                    // Verify each card in played pile was actually from the player who played it
                    game.playedPile.forEach(({card, player}) => {
                        if (!player.playedCards.includes(card)) {
                            errors.push(`Card ${card.name} in played pile but not in ${player.name}'s played cards`);
                        }
                    });
                }
                
                // Validate played cards are actually played
                if (game.state === 'PLAY') {
                    [game.player, game.computer].forEach(player => {
                        player.playedCards.forEach(card => {
                            const inPile = game.playedPile.some(p => p.card === card && p.player === player);
                            const currentlyPlayed = game.currentCount > 0;
                            
                            // If card is marked as played, it should either be in current pile or pile was reset
                            if (currentlyPlayed && !inPile && game.playedPile.length > 0) {
                                // This might be ok if pile was reset, but flag for review
                            }
                        });
                    });
                }

                // ===== SCORING MECHANICS VALIDATION =====
                
                // Check that pegging scores are reasonable per card
                // Max single card score: 15 for 2, pair for 6, run of 7 for 7, 31 for 2 = could be ~17 in perfect scenario
                // But realistically should not exceed 8-12 per card
                if (game.state === 'PLAY' && game.playedPile.length > 0) {
                    // This is checked via message parsing for impossible scores
                }

                // ===== HIS HEELS VALIDATION =====
                
                // If cut card is Jack, dealer should have gotten 2 points
                // (This would need game state tracking from start, leaving as future enhancement)

                return errors;
            }

            trackScoringFromMessages(messages, gameNum) {
                // Impossible scores in cribbage: 19, 25, 26, 27, and > 29
                const impossibleScores = [19, 25, 26, 27];
                let totalHandCribScoring = { player: 0, computer: 0 };
                let heelsCount = 0;
                
                // Parse game messages to extract scoring information
                messages.forEach(msg => {
                    // Hand scoring: "Player scores 15 from hand"
                    const handMatch = msg.match(/(Player|Computer) scores (\d+) from hand/);
                    if (handMatch) {
                        const score = parseInt(handMatch[2]);
                        const player = handMatch[1].toLowerCase();
                        totalHandCribScoring[player] = (totalHandCribScoring[player] || 0) + score;
                        
                        // Check for impossible scores
                        if (impossibleScores.includes(score) || score > 29) {
                            this.stats.errorsDetected++;
                            this.log(`‚ùå IMPOSSIBLE HAND SCORE: ${score} points (${handMatch[1]}, Game ${gameNum})`, 'error');
                        }
                        
                        if (score > this.detailedStats.highestHand.score) {
                            this.detailedStats.highestHand = {
                                score: score,
                                player: handMatch[1],
                                cards: '', // Would need game instrumentation to get cards
                                game: gameNum
                            };
                        }
                        if (score === 29) {
                            this.detailedStats.perfectHands++;
                        }
                    }
                    
                    // Crib scoring: "Player scores 12 from crib"
                    const cribMatch = msg.match(/(Player|Computer) scores (\d+) from crib/);
                    if (cribMatch) {
                        const score = parseInt(cribMatch[2]);
                        const player = cribMatch[1].toLowerCase();
                        totalHandCribScoring[player] = (totalHandCribScoring[player] || 0) + score;
                        
                        // Check for impossible scores
                        if (impossibleScores.includes(score) || score > 29) {
                            this.stats.errorsDetected++;
                            this.log(`‚ùå IMPOSSIBLE CRIB SCORE: ${score} points (${cribMatch[1]}, Game ${gameNum})`, 'error');
                        }
                        
                        if (score > this.detailedStats.highestCrib.score) {
                            this.detailedStats.highestCrib = {
                                score: score,
                                player: cribMatch[1],
                                cards: '',
                                game: gameNum
                            };
                        }
                    }
                    
                    // His heels: "Computer scores 2 for his heels"
                    if (msg.includes('scores 2 for his heels')) {
                        heelsCount++;
                    }
                    
                    // Go points: "Player scores 1 for go"
                    if (msg.includes('scores 1 for go')) {
                        this.detailedStats.goPoints++;
                    }
                    
                    // Pegging validation - check for impossible pegging scores
                    // "Pair for 2", "Three of a kind for 6", "Four of a kind for 12", "Run of X for X", "15 for 2", "31 for 2"
                    const peggingPatterns = [
                        /Pair for (\d+)/,
                        /Three of a kind for (\d+)/,
                        /Four of a kind for (\d+)/,
                        /Run of (\d+) for (\d+)/,
                        /15 for (\d+)/,
                        /31 for (\d+)/
                    ];
                    
                    peggingPatterns.forEach(pattern => {
                        const match = msg.match(pattern);
                        if (match) {
                            const score = parseInt(match[match.length - 1]);
                            // Validate expected scores
                            if (msg.includes('Pair for') && score !== 2) {
                                this.stats.errorsDetected++;
                                this.log(`‚ùå WRONG PAIR SCORE: ${score} (should be 2) - Game ${gameNum}`, 'error');
                            }
                            if (msg.includes('Three of a kind for') && score !== 6) {
                                this.stats.errorsDetected++;
                                this.log(`‚ùå WRONG THREE OF A KIND SCORE: ${score} (should be 6) - Game ${gameNum}`, 'error');
                            }
                            if (msg.includes('Four of a kind for') && score !== 12) {
                                this.stats.errorsDetected++;
                                this.log(`‚ùå WRONG FOUR OF A KIND SCORE: ${score} (should be 12) - Game ${gameNum}`, 'error');
                            }
                            if (msg.includes('15 for') && score !== 2) {
                                this.stats.errorsDetected++;
                                this.log(`‚ùå WRONG 15 SCORE: ${score} (should be 2) - Game ${gameNum}`, 'error');
                            }
                            if (msg.includes('31 for') && score !== 2) {
                                this.stats.errorsDetected++;
                                this.log(`‚ùå WRONG 31 SCORE: ${score} (should be 2) - Game ${gameNum}`, 'error');
                            }
                            if (msg.includes('Run of')) {
                                const runLength = parseInt(match[1]);
                                if (score !== runLength) {
                                    this.stats.errorsDetected++;
                                    this.log(`‚ùå WRONG RUN SCORE: Run of ${runLength} scored ${score} (should be ${runLength}) - Game ${gameNum}`, 'error');
                                }
                                if (runLength < 3 || runLength > 7) {
                                    this.stats.errorsDetected++;
                                    this.log(`‚ùå INVALID RUN LENGTH: ${runLength} (should be 3-7) - Game ${gameNum}`, 'error');
                                }
                            }
                        }
                    });
                });
                
                // Validate his heels only happens once per game max
                if (heelsCount > 1) {
                    this.stats.errorsDetected++;
                    this.log(`‚ùå HIS HEELS SCORED MULTIPLE TIMES: ${heelsCount} times in Game ${gameNum}`, 'error');
                }
            }
        }

        // Initialize simulator
        const simulator = new GameSimulator();
        simulator.log('Game simulator ready. Click "Run Simulation" to test multiple games.', 'success');
    </script>
</body>
</html>
